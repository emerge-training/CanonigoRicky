import jk.log
import jk.sqlite
import jk.mysql
import jk.sql
import jk.env
import jk.time

class:

model NoteList
{
    id as string
    noteTitle as string
    content as string
    timeStampAdded as long
    timeStampLastUpdated as long
}

const NOTELIST = "notelist"
pvar db as MySQLDatabase

func forContext(ctx as LoggingContext) static as this
{
    var cstr = EnvironmentVariable.get("NOTELIST_DATABASE")
    Log.debug(ctx, "Opening database connection: `"..cstr.."'")
    db = MySQLDatabase.forConnectionStringSync(ctx, cstr)
    if not db:
        Error.throw("failedToConnectToDatabase",cstr)
    var v = new this()
    v.setDb(db)
    return v
}

func updateTable(table as SQLTableInfo)
{
    if not table:
        Error.throw("nullTable","updateTable")
    if not db:
        Error.throw("nullDb","updateTable")
    if not db.ensureTableExistsSync(table):
        Error.throw("failedToUpdateTable",table.getName())
    
}

func updateTables
{
    var notelist = SQLTableInfo.forName(NOTELIST)
    notelist.addStringKeyColumn("id")
    notelist.addStringColumn("noteTitle")
    notelist.addStringColumn("content")
    notelist.addStringColumn("timeStampAdded")
    notelist.addStringColumn("timeStampLastUpdated")
    updateTable(notelist)
}

func addNoteList(notelist as NoteList) as NoteList
{
    assert notelist
    notelist.setId("1")
    notelist.setTimeStampAddedValue(SystemClock.asUTCSeconds())
    assert db.executeSync(db.prepareInsertStatementSync(NOTELIST, notelist.toDynamicMap()))
    return notelist
}

func updateNoteList(id as string, notelist as NoteList) as bool
{
    assert notelist
    notelist.setTimeStampLastUpdatedValue(SystemClock.asUTCSeconds())
    var criteria = new NoteList()
    criteria.setId(id)
    return db.executeSync(db.prepareUpdateStatementSync(NOTELIST, criteria.toDynamicMap(), notelist.toDynamicMap()))
}

func deleteNoteList(id as string) as bool
{
    var criteria = new NoteList()
    criteria.setId(id)
    return db.executeSync(db.prepareDeleteStatementSync(NOTELIST, criteria.toDynamicMap()))
}

func geNoteList as DynamicMap
{
    var v = new vector<NoteList>
    var it = assert db.querySync(db.prepareQueryAllStatementSync(NOTELIST)):
        return null
    while it{
        var o = it.next()
        if  not o:
            break
        var notelist = NoteList.forJsonObject(o)
        if not notelist:
            continue
        v += notelist
    }
    var data = new DynamicMap()
    data.setObject("records", v)
    return data 
}

func close
{
    if  db:
        db.closeSync()
    
    db = null
}
